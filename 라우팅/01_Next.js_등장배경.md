# Next.js가 등장하게 된 이유

> 이 글에선 웹 개발의 흐름을 간단히 살펴보며, 왜 Next.js가 등장하게 되었는지 알아본다.  
> 기술은 늘 문제 해결에서 출발한다. Next.js 역시 마찬가지다.

## 초창기 웹

초창기 웹은 정적인 HTML 파일을 서버에서 직접 내려주는 구조였다.  
사용자가 특정 페이지를 요청하면, 서버는 미리 만들어진 HTML 파일을 그대로 응답했다.

이 방식은 단순하고 빠르지만, 사용자마다 다른 데이터를 보여주거나, 실시간으로 콘텐츠를 바꾸는 **동적인 처리에는 한계**가 있었다.

## 템플릿 엔진의 등장

이 한계를 해결하기 위해 템플릿 엔진이 등장했다.  
HTML 안에 변수, 조건문, 반복문 등을 넣고, 서버에서 HTML을 동적으로 생성할 수 있게 되었다.

하지만 여전히 문제는 있었다. **사용자가 어떤 상호작용을 하더라도 전체 페이지를 다시 불러와야 했다.**

## Ajax

Ajax는 이러한 불편함을 해결해줬다.  
전체 페이지를 새로 고치지 않고도 서버와 비동기적으로 데이터를 주고받을 수 있게 되면서, **데이터 처리와 UI가 분리**되기 시작했다.

이를 통해 버튼 클릭이나 스크롤 등 사용자 동작에 따라 일부 화면만 동적으로 갱신되는, **인터랙티브한 웹**이 가능해졌다.

## jQuery

Ajax를 실제로 활용하려면 브라우저 간 호환성이나 복잡한 문법을 감당해야 했다.  
이런 문제를 해결한 것이 jQuery였다.

jQuery는 Ajax 요청을 간단하게 만들고, DOM 조작도 쉽게 처리할 수 있게 해주며 **당시 웹 개발의 표준처럼 자리잡았다.**

하지만 시간이 지나며 웹 애플리케이션은 점점 더 복잡해졌고, **상태 관리, 화면 전환, 컴포넌트 재사용** 같은 요구가 생겨났다. jQuery만으로는 이런 복잡성을 감당하기 어려웠다.

## React

이러한 흐름 속에서 등장한 것이 React였다.  
React는 UI를 컴포넌트 단위로 분리하고, 상태 변화에 따라 필요한 부분만 효율적으로 다시 렌더링함으로써, **복잡한 UI를 더 예측 가능하고 관리하기 쉽게 만들었다.**

React 기반의 SPA(Single Page Application)는 페이지 전환이 빠르고 부드럽지만, 초기 로딩 속도가 느리고 SEO에 불리하다는 단점이 있었다. 이로 인해 **서버 사이드 렌더링(SSR)**이 다시 주목받기 시작했다.

## Next.js

React로 SSR을 직접 구현하려면 서버 구성, 라우팅, 번들링, 데이터 패칭, 인프라 관리 등 다양한 기술을 별도로 구성해야 했다.  
또한 화면 개발 외에도 API 서버 구성, 인증 처리, 데이터 처리 같은 **비즈니스 로직까지 개발자가 모두 맡아야 하는 어려움**이 있었다.

Next.js는 이러한 문제를 해결하기 위해 등장했다.

- **React 기반**으로 동작하면서도,
- **SSR, SSG, CSR을 자유롭게 선택**할 수 있도록 지원하고,
- **파일 기반 라우팅**, **API 라우트**, **이미지 최적화** 등 실무에 필요한 기능들을 기본으로 제공한다.

덕분에 복잡한 설정 없이도 빠르게 웹앱을 만들 수 있고, **UI와 백엔드를 한 프로젝트 안에서 유연하게 통합**할 수 있게 되었다.

## 💡 마무리: 기술은 문제를 해결하며 진화한다

기술은 언제나 **기존의 문제를 해결하기 위해 등장한다.**  
Next.js 역시 React가 가진 한계를 실무 관점에서 보완하려는 시도에서 출발했다.

이처럼 **기술의 등장 배경과 흐름을 이해하면, 새로운 도구를 단순히 배우는 것을 넘어 '왜 필요한가'를 납득하고 제대로 활용할 수 있게 된다.**

> 과거의 문제를 돌아보는 일은, 오늘의 기술을 더 깊이 이해하는 가장 좋은 길이다.
